import{_ as l,c as o,b as s,d as n,e as p,w as e,a as t,r as c,o as r}from"./app.1b85acd6.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"never","slug":"never","link":"#never","children":[]}],"relativePath":"typescript/never/index.md"}'),y={name:"typescript/never/index.md"},F=t("",8);function D(i,C,A,d,f,v){const a=c("font");return r(),o("div",null,[F,s("p",null,[n("然而他忘记同时修改 controlFlowAnalysisWithNever 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 boolean 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保 controlFlowAnalysisWithNever 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论："),s("b",null,[p(a,{color:"#26c6da"},{default:e(()=>[n("使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。")]),_:1})])])])}const h=l(y,[["render",D]]);export{_ as __pageData,h as default};
