import{_ as s,c as e,o as a,a as n}from"./app.1b85acd6.js";const D=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"tree-shaking","slug":"tree-shaking","link":"#tree-shaking","children":[]},{"level":2,"title":"SideEffect（副作用）","slug":"sideeffect-副作用","link":"#sideeffect-副作用","children":[]},{"level":2,"title":"按需导入","slug":"按需导入","link":"#按需导入","children":[]}],"relativePath":"treeshaking/index.md"}'),o={name:"treeshaking/index.md"},l=n(`<h2 id="tree-shaking" tabindex="-1">tree-shaking <a class="header-anchor" href="#tree-shaking" aria-hidden="true">#</a></h2><p><strong><em>Tree-shaking (摇树)</em></strong> 是一个术语，通常指通过打包工具&quot;摇&quot;我们的代码，将未引用代码 (Dead Code) &quot;摇&quot; 掉。在打包工具构建的项目中，都有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝，虽然依赖了某些模块，但其实只使用其中的某些方法，通过 Tree Shaking ，将没有使用的方法摇掉，这样来达到删除无用代码的目的。</p><p>tree-shaking 虽然能够消除无用代码，但仅针对 ES6 模块语法，因为 ES6 模块采用的是静态分析，从字面量对代码进行分析。对于必须执行到才知道引用什么模块的 CommonJS 动态分析模块他就束手无策了。</p><p>例如下面代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> myModlue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> (Math</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">random</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0.5</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">myModlue</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">require</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">myModlue</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">require</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">b</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>请问此时哪个模块用到了，哪个模块没用到？</p><p>不过我们可以通过插件支持 CommonJS 转 ES6 然后实现 tree-shaking。</p><p>treeshake 大概是这样：</p><ol><li>模块解析</li><li>标记代码或模块是否可 Tree-shaking</li><li>去除无用代码或模块</li><li>通过 chunks 生成代码(字符串)并写入文件</li></ol><h2 id="sideeffect-副作用" tabindex="-1">SideEffect（副作用） <a class="header-anchor" href="#sideeffect-副作用" aria-hidden="true">#</a></h2><p><strong><em>sideEffetcs（package.json 配置项）</em></strong> 作用于整个模块，它不会分析整个模块内部的代码是否具有副作用：</p><p>当你对模块设置了 <code>&quot;sideEffects&quot;: false</code>，就表明这个模块没有副作用，相当于告诉 Webpack：喂！我没有副作用啊，如果我的导出值没有被别的模块使用那就请把我清除掉吧！</p><p>当你对模块设置了 <code>&quot;sideEffects&quot;: true</code>，就表明这个模块有副作用，相当于告诉 Webpack：喂！我有副作用啊，就算我没有被别的模块导入（指导出值被使用）也不要把我清除啊！</p><p>也就是说，只要你的包不是用来做 <strong><em>polyfill</em></strong> 之类的事情，就尽管放心的给他加上 <code>sideEffects: false</code> 吧！</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>polyfill 举个例子，老浏览器不支持 Map， <code>new Map()</code>会报错，那么我就用 Object 的方式实现一个 Map 的构造函数，那么再<code>new Map()</code>就不会报错了。</p></div><p>因此，对于 CSS 文件，需要使用 <code>sideEffects: [&#39;css文件路径&#39;]</code> 标记所有 CSS 文件，来保留所有 CSS 文件，以及对 CSS 文件的导入语句。</p><p>如果你仍想对 CSS 文件使用 <code>&quot;sideEffects: false&quot;</code>，并且想保留这个 CSS 文件，可以这样：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> styleeee </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./style.css</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(styleeee)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>这样的话，CSS 文件的导出值（默认导出值）被消费，Terser 就不会将其 shake 掉。</p><p>还有 <strong><em>optimization.usedExports（webpack 配置项）</em></strong>，开启后利用 <code>/*#__PURE__*/</code> 注释标记一个 <strong><em>函数调用</em></strong> 不存在副作用，让 webpack 放心 <strong><em>“摇”</em></strong> 起来</p><p>参考 <a href="https://webpack.docschina.org/guides/tree-shaking/" target="_blank" rel="noreferrer">webpack tree-shaking 文档</a>。</p><p>在 rollup 中，通过 <a href="https://rollupjs.org/configuration-options/#treeshake" target="_blank" rel="noreferrer">treeshake 配置</a>项来控制 treeshake。</p><h2 id="按需导入" tabindex="-1">按需导入 <a class="header-anchor" href="#按需导入" aria-hidden="true">#</a></h2><p>假如你的开发环境使用了 npm 或者 yarn 等包管理工具，并且使用 webpack，rollup 等打包工具进行构建，你所引入的大型类库，组件库都可使用 tree-shaking 特性只打包需要的模块以减少包体积。</p><p>随便来几个相关按需导入介绍：<a href="https://arco.design/vue/docs/start" target="_blank" rel="noreferrer">arco design</a>, <a href="https://element-plus.gitee.io/zh-CN/guide/quickstart.html#%E6%8C%89%E9%9C%80%E5%AF%BC%E5%85%A5" target="_blank" rel="noreferrer">ElementPlus UI</a>, <a href="https://echarts.apache.org/handbook/zh/basics/import" target="_blank" rel="noreferrer">Echarts</a>等。</p><p>大多 UI 组件库会提供两种按需导入方式：</p><ol><li>自动导入 所有工作有插件完成。</li><li>手动导入 组件的导入手动完成，样式的导入由插件完成。</li></ol>`,27),t=[l];function p(r,c,i,d,y,h){return a(),e("div",null,t)}const f=s(o,[["render",p]]);export{D as __pageData,f as default};
