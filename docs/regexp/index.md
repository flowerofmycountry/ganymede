## 元字符

| 代码 |                                  说明                                  |
| :--: | :--------------------------------------------------------------------: |
|  .   |                       匹配除换行符以外的任意字符                       |
|  \w  | 匹配字母或数字或下划线或汉字，不考虑汉字的话和 `[a-z0-9A-Z_]` 完全一致 |
|  \s  |                            匹配任意的空白符                            |
|  \d  |                      匹配数字,和 `[0-9]` 完全一致                      |
|  \b  |                          匹配单词的开始或结束                          |
|  ^   |                            匹配字符串的开始                            |
|  $   |                            匹配字符串的结束                            |

`\b` 匹配一个单词边界，也就是指空格，标点符号或者换行的位置。例如，`er\b` 可以匹配 `"never"` 中的 `"er"`，但不能匹配 `"verb"` 中的 `"er"`。

当 `^` 和 `$` 同时使用有完全匹配的意思。

`/^\d{5,12}$/` 表示以数字开头结尾的 5-12 位数字。

`/\d{5,12}/` 表示包含的 5-12 位数字。

## 字符转义 `\`

字符集合 `[]` 外，需要转义的有 `.`，`^`，`$`，`*`，`+`，`?`，`\`，`{`，`}`，`(`，`)`，`[`，`]`，`|`。

字符集合 `[]` 内，需要转义的有 `^`。

## 字符集合 `[]`

像 `[aeiou]` 就匹配任何一个英文元音字母，`[.?!]` 匹配标点符号( `.` 或 `?` 或 `!` )。

`^` 在字符集合内有取反的意思。`[^aeiou]` 除了英文元音字母以外其他的任意字符。

## 重复

|  代码   |              说明               |
| :-----: | :-----------------------------: |
|   \*    | 指定前边的内容重复零次或更多次  |
|   \+    | 指定前边的内容重复一次或更多次  |
|    ?    |  指定前边的内容重复零次或一次   |
|  \{n\}  |     指定前边的内容重复 n 次     |
| \{n,\}  | 指定前边的内容重复 n 次或更多次 |
| \{n,m\} |  指定前边的内容重复 n 到 m 次   |

## 分枝条件 `|`

分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用 `|` 把不同的规则分隔开。

`0\d{2}-\d{8}|0\d{3}-\d{7}` 这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8 位本地号(如 `010-12345678` )，一种是 4 位区号，7 位本地号( `0376-2233445` )。

## 反义

|   代码   |                    说明                    |
| :------: | :----------------------------------------: |
|    \W    | 匹配任意不是字母，数字，下划线，汉字的字符 |
|    \S    |          匹配任意不是空白符的字符          |
|    \D    |            匹配任意非数字的字符            |
|    \B    |        匹配不是单词开头或结束的位置        |
|   [^x]   |         匹配除了 x 以外的任意字符          |
| [^aeiou] |  匹配除了 aeiou 这几个字母以外的任意字符   |

## 分组 `()`

想要重复多个字符可以用小括号来指定子表达式(也叫做分组)。

`(\d{1,3}\.){3}\d{1,3}` 是一个简单的 IP 地址匹配表达式。`192.168.1.1`

## 向后引用

分组后的表达式会被自动编号，从 1 开始，第二个为 2，以此类推。后面想引用的话，用 `\1` ，`\2`，... 来表示。

`\b(\w+)\b\s+\1\b` 可以用来匹配重复的单词，像 `go go`, 或者 `kitty kitty`。相当于 `\b\w+\b\s+\w+\b`。

也可以自己给分组命名。

## 回溯与性能

先看一个正则：`/^\d+0$/.test("11110")`。

1. `\d+` 匹配 `11110`
2. `0` 发现没有东西匹配，此时正则逻辑会**回溯**一位，`\d+` 匹配 `1111`，留出一个 `0`
3. `0` 匹配 `0`，匹配结束。返回 `true`。

上面的能明白，再看一个：`/^(\d+)+$/.test("1111x")`

1. `\d+` - `1111x` 无法匹配，此时正则逻辑会**回溯**一位，`\d+` 匹配 `1111`，留出一个 `x`。
2. `\d+` - `x` 无法匹配，此时正则逻辑会**回溯**一位，`\d+` 匹配 `111`，留出一个 `1x`。
3. `\d+` - `1x`，看一下第一步，`1x` 是不是和 `1111x` 非常像，没错他会重复做之前的逻辑。
4. ...... 整个过程就是一个大的递归。
5. 不停**回溯**直到 `\d+` 匹配 `1`，留出一个 `111x`。
6. `\d+` - `111x` 做递归匹配，最后无法满足，返回 `false`。

由此可看出当 `1111x` 位数变多时，性能消耗成指数级递增。

下面的例子说明了正则优化的必要性：

```javascript
const executeWithTimer = (fn) => {
  const start = new Date();
  fn();
  const end = new Date();

  console.info(`程序运行时间为${end.getTime() - start.getTime()} ms`);
};

executeWithTimer(() => {
  const regExp = /^(\d*\s?)*$/;
  const better = /^(\d*\s)*\d*$/; // 优化后有效减少回溯
  const data1 = "1 12 123 1234 12345 123456";
  const data2 = "1 12 123 1234 12345 12345x";
  const data3 = "1 12 123 1234 12345 123456 123456x";
  console.log(`正则表达式测试${regExp.test(data3) ? "通过" : "失败"}`);
});
```

## 其他

- [参考 1](https://www.jb51.net/tools/zhengze.html)
- [参考 2](https://juejin.cn/post/6844903494906806279)
- [可视化](<https://jex.im/regulex/#!flags=&re=%5E(a%7Cb)*%3F%24>)
